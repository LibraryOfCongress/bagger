apply plugin: 'eclipse'

eclipse.classpath.file.withXml { xml ->
  def node = xml.asNode()

  Set<String> projectNames = new HashSet<>()
  findProjectDependencies(project).each { projectNames.add(it.name) }

  //modify eclipse classpath so that we don't export test dependencies
  (configurations.testCompile - configurations.compile).each { dependency ->
    Node toRemove = node.find {it.@path == "${dependency.path.replace('\\', '/')}"}
    if ( toRemove != null ){
      node.remove(toRemove)
    }

    //remove the path from the dependency name and drop the .jar ending
    String dep = dependency.path.tokenize('/')[-1] - ".jar"

    //don't add the project jars to the classpath
    if ( !projectNames.contains(dep) ) {
      node.appendNode( 'classpathentry', [ kind: 'lib', path: "$dependency.path"])
    }
  }

  //make resources lib instead of src kind
  Node resources = node.find {it.@path == "src/main/resources"}
  if(resources != null){
    resources.attributes().put("kind", "lib")
    resources.attributes().put("exported", "true")
  }
  resources = node.find {it.@path == "src/test/resources"}
  if(resources != null){
    resources.attributes().put("kind", "lib")
    resources.attributes().put("exported", "false")
  }
}

eclipse.project.file.withXml { provider ->
  ignoreDerivedResources(provider.asNode())
}

def ignoreDerivedResources(projectDescription, directories = ["build", "target", "test-output"]) {
  def count = directories.count { file(it).exists() }
  if (count > 0) {
    def filter = projectDescription
      .appendNode("filteredResources")
      .appendNode("filter")
    filter.appendNode("id", System.currentTimeMillis().toString().trim())
    filter.appendNode("type", "26")
    filter.appendNode("name")
    def matcher = filter.appendNode("matcher")
    matcher.appendNode("id", "org.eclipse.ui.ide.orFilterMatcher")
    def arguments = matcher.appendNode("arguments")
    directories.each {
      if (file(it).exists()) {
        def dirMatcher = arguments.appendNode("matcher")
        dirMatcher.appendNode("id", "org.eclipse.ui.ide.multiFilter")
        dirMatcher.appendNode("arguments", "1.0-projectRelativePath-matches-false-false-${it}")
      }
    }
  }
}

//find all inter-project dependencies including parent project
def Set<Project> findProjectDependencies(Project parent){
  Set<Project> projects = new HashSet<>()
  projects.add(parent)

  parent.configurations.testRuntime.getAllDependencies().withType(ProjectDependency).each {
    Project p = it.getDependencyProject()
    projects.add(p)
    projects.addAll(findProjectDependencies(p))
  }

  return projects
}
